# 3D游戏与计算机图形学中的数学方法

## 一、全书框架

### 📚 全书框架

全书由**16章主体章节**和**5个附录**构成，循序渐进地搭建知识体系。

- **主体章节（第1-16章）**：构成了本书的核心。 

- **数学基石（第2-4章）**：系统回顾**向量**运算、**矩阵**理论（包括线性方程组、逆矩阵、行列式、特征值）与**坐标变换**（线性变换、齐次坐标、四元数），为后续所有应用奠定基础。

- **图形几何核心（第5-11章）**：深入探讨三维空间中的**几何学**（直线、平面、视锥）、**光线跟踪**求交计算、**光照与着色**模型、**可见性判断**技术、**多边形技术**、**阴影**算法以及**曲线与曲面**的表示（如Bézier曲线、B样条）。

- **交互与仿真（第12-16章）**：扩展到动态与交互领域，涵盖**碰撞检测**、**线性**与**旋转物理运动**（刚体动力学）、**流体与织物仿真**以及支撑上述仿真的**数值方法**（如微分方程求解）。

- **附录（A-E）**：提供必要的数学背景补充，包括复数、三角恒等式、坐标系、泰勒级数以及习题答案。

全书内容组织体现了**循序渐进**的特点：从基础的向量、矩阵数学，逐步过渡到几何、光照、物理仿真等高级主题。第3版特别补充了投影、阴影、布料模拟、数值方法等新内容，并更新了相关代码与技术插图。

### 章节主题

为快速把握全书脉络，以下是各章核心数学主题的提炼：

| 章节                        | 核心数学主题         | 关键内容要点（游戏开发相关）                                 |
| --------------------------- | -------------------- | ------------------------------------------------------------ |
| **第1章：渲染管线**         | **图形管线流程概述** | 坐标变换链（对象→世界→相机→裁剪→屏幕空间）、顶点属性插值     |
| **第2章：向量**             | **向量运算及应用**   | 向量性质、长度、单位化；**内积（点积）**（夹角、投影）；**外积（叉积）**（垂直向量、面积）；正交化算法 |
| **第3章：矩阵**             | **矩阵理论与求解**   | 矩阵运算；线性方程组求解；逆矩阵；行列式（几何意义）；特征值与特征向量 |
| **第4章：坐标变换**         | **线性变换工具**     | 齐次坐标（处理平移）；正交矩阵（旋转变换）；**四元数**（旋转表示与插值） |
| **第5章：3D引擎中的几何学** | **3D基本几何对象**   | 直线/平面方程与交点；**视锥**构造与平面提取；**透视校正**插值；**投影矩阵**推导 |
| **第6章：光线跟踪**         | **光线求交计算**     | 多项式求根（解析与数值）；光线与基本图元（球、三角形等）求交；反射/折射向量计算 |
| **第7章：光照与着色**       | **光照模型与映射**   | 光源模型；**Blinn-Phong**着色模型；纹理映射；凹凸映射；**Cook-Torrance**物理光照模型 |
| **第8章：可见性判断**       | **空间加速结构**     | 包围体（球、盒）测试；空间分割（**八叉树**、**BSP树**）      |
| **第9章：多边形技术**       | **多边形处理技术**   | 深度偏移、公告牌、多边形化简与三角化                         |
| **第10章：阴影**            | **阴影生成算法**     | 阴影集判断、**阴影映射**、模板阴影                           |
| **第11章：曲线与曲面**      | **参数曲线曲面**     | **Bézier曲线**、**B样条**、NURBS                             |
| **第12章：碰撞检测**        | **物体交互检测**     | 运动/静止物体碰撞检测、表面滑行                              |
| **第13章：线性物理运动**    | **经典运动力学**     | 二阶微分方程、抛物运动、阻尼、摩擦力                         |
| **第14章：旋转物理运动**    | **旋转动力学**       | 角速度、离心力与科里奥利力、**刚体运动**（惯性张量）、振动系统 |
| **第15章：流体与织物仿真**  | **连续介质仿真**     | **波动方程**（流体）、**弹簧阻尼系统**（织物）               |
| **第16章：数值方法**        | **计算数学基础**     | 线性方程组求解、特征值计算、常微分方程数值解                 |

### 数学方法与游戏开发的关联全景

贯通上述数学主题，其在游戏开发中的主要应用可归纳为五大领域：

1. **图形渲染**：这是数学应用最密集的领域，涉及**渲染管线**中的坐标变换、**光照与着色**模型计算、**纹理映射**以及**多边形**的最终屏幕绘制。

1. **几何处理**：处理虚拟世界中的形状与空间关系，包括三维**几何学**计算、**视锥裁剪**、**光线跟踪**（用于求交和反射）以及**曲线与曲面**的建模。

1. **物理仿真**：为游戏世界注入真实感，涵盖**线性**与**旋转物理运动**、**碰撞检测**、**流体与织物仿真**，其背后依赖于**数值方法**求解运动方程。

1. **可见性与优化**：保障复杂场景的实时渲染性能，通过**包围体测试**和**空间分割**技术（如八叉树、BSP树）高效剔除不可见物体，优化碰撞检测。

1. **动画与变换**：实现物体的平滑运动和变形，核心工具是**矩阵**、**四元数**以及用于旋转插值的**球型线性插值（SLERP）**。

总而言之，本书构建了一个从**基础数学工具** → **静态图形几何** → **动态物理仿真**的完整知识框架，每一部分都紧密对应着现代3D游戏开发中一个不可或缺的技术环节。

## 二、渲染管线：从对象空间到屏幕空间的矩阵之旅

顶点在GPU渲染管线中的旅程，本质上是一系列矩阵变换的串联。本章将基于第2至5章铺垫的向量、矩阵、坐标变换及几何知识，逐层展开这条从对象空间到屏幕空间的完整矩阵变换链。

### 1. 变换链总览：核心坐标空间与矩阵

渲染管线的核心数学任务是完成顶点坐标的如下空间转换序列：

1. **对象空间 (Object Space)** → **世界空间 (World Space)**：通过**模型变换矩阵 (Model Matrix)**。

1. **世界空间 (World Space)** → **相机/观察空间 (Camera/View Space)**：通过**视图变换矩阵 (View Matrix)**。

1. **相机空间 (Camera Space)** → **齐次裁剪空间 (Homogeneous Clip Space)**：通过**投影矩阵 (Projection Matrix)**。

1. **齐次裁剪空间** → **屏幕空间 (Screen Space)**：通过**透视除法**与**视口变换**。

其总变换公式为（对于透视投影）：

 v_clip = M_proj * M_view * M_model * v_object 

最终，经过透视除法  v_ndc = v_clip / v_clip.w 和视口变换，得到屏幕像素坐标。

### 2. 对象空间 → 世界空间：模型变换

对象空间是模型自身的局部坐标系。模型变换矩阵  M_model 是一个4×4的仿射变换矩阵，用于将模型放置、旋转和缩放到世界场景中。其通用形式为：

 M_model = [ [R_3x3, T_3x1]; [0_1x3, 1] ] 

其中  R 是3×3的旋转与缩放矩阵， T 是平移向量。对于一个对象空间顶点  v_object = (x_o, y_o, z_o, 1)^T ，其世界坐标计算为：

 v_world = M_model * v_object 

### 3. 世界空间 → 相机空间：视图变换

视图变换的目的是将世界坐标系变换到以相机为原点的观察坐标系。构造视图矩阵  M_view 等价于求取相机在世界中位姿的逆变换。

设相机在世界中的位置为  C ，其朝向（视线方向）为单位向量  d ，向上方向为  u ，则向右方向  r = u × d （叉积）。视图矩阵可直接构造为：

```
M_view = [ [ r.x,  r.y,  r.z,  -dot(r, C) ];
           [ u.x,  u.y,  u.z,  -dot(u, C) ];
           [-d.x, -d.y, -d.z,  dot(d, C) ];
           [   0,    0,    0,          1 ] ]
```







此矩阵将相机移动到原点，并将  d 旋转对齐到  -z 轴（假设采用看向  -z 的右手坐标系）。世界空间顶点变换为： v_camera = M_view * v_world 。

**模型-视图矩阵**  M_mv = M_view * M_model 常被合并使用，一次性完成从对象空间到相机空间的转换。

### 4. 相机空间 → 裁剪空间：投影变换

这是最关键且数学上最复杂的一步，分为**透视投影**和**正交投影**。

#### 透视投影矩阵推导与参数化

透视投影将视锥体（平截头体）映射到齐次裁剪空间下的单位立方体（如OpenGL的  [-1, 1]^3 ）。其推导基于相似三角形原理。

**通用矩阵形式** (OpenGL风格，相机空间  z ∈ [-f, -n] ，看向  -z )：

```
M_persp = [ [ 2n/(r-l),       0,  (r+l)/(r-l),           0 ];
           [       0,  2n/(t-b),  (t+b)/(t-b),           0 ];
           [       0,        0,  -(f+n)/(f-n),  -2fn/(f-n) ];
           [       0,        0,           -1,           0 ] ]
```







其中：

-  n, f ：近、远裁剪平面距离（正值）。

-  l, r, b, t ：近裁剪平面上左、右、底、顶四条边的坐标。

**参数化控制**：在实际开发中，通常使用**竖直视场角 (FOV_y)**、**宽高比 (Aspect)**、 n 、 f 来定义对称视锥。此时：

```
t = n * tan(FOV_y / 2)
b = -t
r = Aspect * t
l = -r
```







代入通用矩阵后，可得到**对称透视投影矩阵**的简化形式：

```
M_persp_sym = [ [ n/r,     0,           0,           0 ];
               [    0,   n/t,           0,           0 ];
               [    0,     0,  -(f+n)/(f-n),  -2fn/(f-n) ];
               [    0,     0,          -1,           0 ] ]
```







又因为  n/r = cot(FOV_y/2) / Aspect ， n/t = cot(FOV_y/2) ，这也是许多引擎和资料中的常见形式。

**关键影响**：

- **FOV增大** →  cot(FOV/2) 减小 → 矩阵左上角元素减小 → 投影后x, y坐标范围增大，视觉上物体“拉近放大”。

- **Aspect改变** → 仅影响x方向缩放，用于匹配屏幕比例，防止图像拉伸。

- **n/f改变** → 主要影响深度(z)方向的映射和非线性精度分布。

#### 正交投影矩阵

正交投影直接将一个轴对齐长方体映射到NDC立方体，无需透视除法（ w 保持为1）。

其矩阵形式为：

```
M_ortho = [ [ 2/(r-l),       0,        0,  -(r+l)/(r-l) ];
          [       0,  2/(t-b),        0,  -(t+b)/(t-b) ];
          [       0,        0,  -2/(f-n),  -(f+n)/(f-n) ];
          [       0,        0,        0,            1 ] ]
```







### 5. 裁剪空间 → 屏幕空间：透视除法与视口变换

经过投影矩阵变换后，顶点位于**齐次裁剪空间**。此时必须进行**透视校正**的关键步骤：

1. **透视除法 (Perspective Divide)**：  v_ndc = (v_clip.x / v_clip.w, v_clip.y / v_clip.w, v_clip.z / v_clip.w)  对于透视投影， v_clip.w = -v_camera.z ，此操作将顶点映射到**归一化设备坐标 (NDC)**。在OpenGL中NDC范围为  [-1, 1]^3 ，Direct3D中z范围为  [0, 1] 。

1. **视口变换 (Viewport Transform)**： 将NDC坐标映射到最终的屏幕像素坐标。设视口左上角为  (V_x, V_y) ，宽高为  V_w, V_h ，深度缓冲区范围为  [d_min, d_max] （通常为  [0, 1] ），则变换为：

```
x_screen = V_x + (V_w / 2) * (x_ndc + 1)
y_screen = V_y + (V_h / 2) * (y_ndc + 1) // 注意：屏幕y轴通常向下，可能与NDC y轴方向相反
z_screen = d_min + (d_max - d_min) * ( (z_ndc + 1) / 2 ) // OpenGL NDC z∈[-1,1]时
```







### 6. 在现代游戏引擎中的实现

上述数学理论直接对应游戏引擎的渲染API和着色器代码。

- **在Unity中**：

- 顶点着色器通常使用内置宏或函数完成变换： 

```
// 旧版
float4 clipPos = mul(UNITY_MATRIX_MVP, v.vertex);
// 新版URP/HDRP
float4 clipPos = TransformObjectToHClip(v.positionOS.xyz);
```







-  UNITY_MATRIX_MVP 即为  M_proj * M_view * M_model 。相机参数（FOV, Aspect, Near, Far）通过Camera组件设置，自动计算投影矩阵。

- **在Unreal Engine中**：

- 变换同样在顶点着色器中完成，矩阵由引擎渲染管线提供。材质蓝图中的  Transform 节点可以方便地在不同空间之间转换位置或向量。

- 投影矩阵的结构与上述推导一致，但可能因API（DirectX 11/12）的不同而在z范围映射上略有调整。

至此，顶点完成了从局部对象定义到最终屏幕像素位置的完整数学旅程。这套矩阵变换链是渲染所有3D几何体的基石，其正确性与效率直接决定了后续光照、着色、裁剪等所有图形算法的视觉效果与性能。

## 三、光照与着色：Blinn-Phong到PBR的数学演进

渲染管线将顶点变换至屏幕，完成了几何的“定位”。下一个核心步骤，是为这些几何表面赋予正确的“外观”，这由**光照与着色模型**计算决定。在第1-6章准备好的向量、矩阵、坐标变换与几何求交工具基础上，本章聚焦于模拟光与表面交互的核心数学模型及应用演进。

### **3.1 传统经验模型：Blinn-Phong的向量几何**

用 **Blinn-Phong模型** 计算表面一点的颜色 

$I$﻿

，其数学本质是三个向量（光源方向 

$\mathbf{L}$﻿

、视线方向 

$\mathbf{V}$﻿

、法线 

$\mathbf{N}$﻿

）的点积运算组合：

﻿

$I = k\_a I\_a + k\_d I\_l (\mathbf{N} \cdot \mathbf{L}) + k\_s I\_l (\mathbf{N} \cdot \mathbf{H})^n$﻿

﻿

**各参数具体意义如下：**

| 参数           | 符号                                        | 意义与作用                                                   |
| -------------- | ------------------------------------------- | ------------------------------------------------------------ |
| **环境光成分** | $k\_a I\_a$                                 | 模拟全局间接光照，与表面朝向无关。                           |
| **漫反射项**   | $k\_d I\_l (\mathbf{N} \cdot \mathbf{L})$   | 模拟朗伯反射，强度正比于**法线**与**光源方向**的点积（余弦值）。 |
| **镜面反射项** | $k\_s I\_l (\mathbf{N} \cdot \mathbf{H})^n$ | 模拟高光，其关键在于引入**半角向量** $\mathbf{H} = (\mathbf{L} + \mathbf{V}) / \|\mathbf{L} + \mathbf{V}\| $﻿，比经典的Phong模型（使用反射向量）计算更高效，高光更柔和自然。 |

此模型是**半经验模型**，其镜面反射项

$(\mathbf{N} \cdot \mathbf{H})^n$﻿

并非基于物理，而是通过指数

$n$﻿

艺术性地控制高光集中度。它为后续更复杂的表面细节模拟与物理模型奠定了基础。

### **3.2 从法线到深度：增强表观细节的纹理计算**

为了在低多边形模型上产生高细节视觉效果，一系列基于纹理的扰动技术被发明。其核心思想是“欺骗”光照计算，而非改变实际几何。

- **法线贴图**：最基础的扰动技术。它将高精度模型的法线方向存储在RGB纹理中（各通道映射到[-1,1]），在光栅化时，**片元着色器**从纹理中采样，将采样的**切线空间法线**（Tangent Space Normal）通过TBN矩阵（由顶点提供的**法线N、切线T、副法线B**构成）转换到世界或视图空间，替代原始插值得到的法线进行光照计算。数学上，世界空间法线通过基变换获得： $\text{世界空间法线} = T \times N\_x + B \times N\_y + N \times N\_z$﻿ 其中$(N\_x, N\_y, N\_z)$﻿为采样并映射后的纹理值。

- **视差映射**：进阶的凹-凸感增强技术。它在法线贴图基础上，引入**高度图（Height Map）**。片元着色器根据当前视线方向 $\mathbf{V}$﻿ 在**切线空间**中的投影和当前位置的高度值，对纹理坐标进行偏移： $\Delta (u, v) = \frac{h(u, v) \cdot \mathbf{V}\_{xy}}{\mathbf{V}\_z}$﻿ 最终使用偏移后的纹理坐标 $(u', v') = (u, v) - \Delta (u, v)$﻿ 进行采样，从而在倾斜视角下产生更真实的表面位移错觉，其数学原理可视为对第6章光线-表面求交的一种高效近似。

### **3.3 物理正确模型：Cook-Torrance与微平面理论**

追求真实感渲染必然走向**基于物理的渲染（PBR）**，其核心是高光反射部分的建模从艺术化公式转向物理光学。**Cook-Torrance光照模型**是这一思想的数学实现。

该模型将双向反射分布函数（BRDF）分解，其高光反射项基于**微平面理论**，认为宏观表面由无数微观镜面组成：

﻿

$f\_{\text{specular}} = \frac{F(\theta) \cdot G(\omega\_i, \omega\_o) \cdot D(\mathbf{h})}{4 (\mathbf{n} \cdot \omega\_i) (\mathbf{n} \cdot \omega\_o)}$﻿

﻿

这个公式由三个核心函数和一组几何项构成，每一项都有其物理意义和数学推导：

1. **菲涅耳项** $F(\theta)$﻿：描述反射率随入射角 $\theta$﻿ 的变化。实践中常用**Schlick近似**： $F(\theta) = F\_0 + (1 - F\_0)(1 - \cos\theta)^5$﻿ 其中 $F\_0$﻿ 是材质在垂直入射时的基础反射率。

1. **微平面分布函数** $D(\mathbf{h})$﻿：描述微观法线 $\mathbf{h}$﻿（半角向量）的统计分布，定义了高光的形状和模糊程度。

- **Beckmann分布**：$D(\mathbf{h}) = \frac{e^{-\tan^2\theta\_h / \alpha^2}}{\pi \alpha^2 \cos^4\theta\_h}$﻿﻿

- **GGX (Trowbridge-Reitz) 分布**（更常用）：$D(\mathbf{h}) = \frac{\alpha^2}{\pi \cos^4\theta\_h (\alpha^2 + \tan^2\theta\_h)^2}$﻿ 其中 $\alpha$﻿ 为粗糙度参数。

1. **几何衰减项** $G(\omega\_i, \omega\_o)$﻿：模拟微平面间的**阴影（Shadowing）和遮蔽（Masking）效应，导致光线在掠射角时衰减。常用Smith模型**，分离为入射和出射两部分乘积 $G_1(\omega\_i) \cdot G_1(\omega\_o)$﻿。

### **3.4 现代引擎实践：从理论到高效实时渲染**

复杂的PBR模型要在实时渲染中应用，离不开现代游戏引擎的工程化实现与优化。

- **Unity**：其标准着色器（Standard Shader）封装了PBR工作流，通过**金属度-粗糙度**参数集来配置材质，使用GGX作为高光分布函数。在性能方面，通过**光照烘焙（Lightmapping）**、**光照探针（Light Probe）** 和**静态/动态批处理**等技术，将昂贵的全局光与实时计算分离，并减少绘制调用。

- **Unreal Engine**：同样采用基于物理的渲染管线，并对光源渲染进行了拓展，例如使用**线性变换余弦（LTC）方法实现对多边形面光源的高效实时计算。对于大型开放世界的全局光照，UE不仅依赖其内置的Lightmass烘焙器，也支持开发自研的GPU烘焙器（如基于Dawn）**，利用光线追踪硬件加速烘焙过程，并使用**双边滤波**或**OptiX降噪器**等技术减少路径追踪带来的噪点。

这种从Blinn-Phong的经验向量计算，到法线/视差映射的表面扰动，再到Cook-Torrance的物理建模，最终在引擎中落地为高效实践的演进过程，完整展现了游戏图形学中光照与着色技术追求**更真实、更高效**的数学与工程双轨驱动。

## 四、物理仿真：刚体、碰撞与弹簧 since系统知数的数值世界

承接之前对静态几何与光照的探讨，物理仿真将数学的触角伸向了动态的交互世界。这一领域的核心任务，是使用数值方法模拟物体在力与约束作用下的运动规律，为游戏世界注入真实的动态反馈。其数学框架主要围绕三大支柱展开：描述实体整体运动的刚体动力学、处理物体交互的碰撞检测与响应，以及模拟柔性体的弹簧-质点系统。

### 一、刚体动力学：平动与转动的统一描述

刚体，即形状和大小不会发生变化的理想物体，其运动由两部分构成：**质心的平动**和**绕质心的转动**。

1. **运动方程**:

- **平动方程** 遵循牛顿第二定律，描述合外力与质心加速度的关系：  F = m acom 

- **转动方程** 更为复杂，由欧拉方程描述，它关联了合外力矩、角加速度和惯性张量： τ = I α + ω × (I ω)  其中， τ 是关于质心的合外力矩， I 是惯性张量， α = ω̇ 是角加速度， ω 是角速度。公式中的  ω × (I ω) 项是陀螺力矩（科里奥利力项），在旋转坐标系中产生。

1. **惯性张量**: 惯性张量  I 是一个 3×3 的对称矩阵，量化了刚体质量分布对绕不同轴旋转的抵抗程度。在物体局部坐标系中，对于 N 个离散质量点 mk ，其位置为 rk = (xk, yk, zk) （相对质心），其分量为：

- **转动惯量**（对角线元素）: 

-  Ixx = Σ mk (yk² + zk²) 

-  Iyy = Σ mk (xk² + zk²) 

-  Izz = Σ mk (xk² + yk²) 

- **惯性积**（非对角线元素）: 

-  Ixy = Iyx = -Σ mk xk yk 

-  Ixz = Izx = -Σ mk xk zk 

-  Iyz = Izy = -Σ mk yk zk  当刚体发生旋转，其世界坐标系中的惯性张量需要通过旋转矩阵  R （从局部到世界）进行变换： Iworld = R Ilocal Rᵀ 。

1. **角速度积分与姿态更新**: 在模拟时间步 Δt 内，需要对角速度进行积分以更新刚体的旋转状态。

- **第一步是更新角动量**  L （ L = I ω ）。根据力矩方程  τ = L̇ ，使用数值积分（如欧拉法）：  L(t+Δt) = L(t) + τ Δt 

- **第二步是反解角速度**： ω(t+Δt) = I⁻¹ L(t+Δt) 

- **第三步是更新旋转姿态**，通常使用四元数  q 来表示。四元数微分方程为： q̇ = (1/2) ω · q ，其中  ω 表示为纯四元数  (0, ωx, ωy, ωz) ，“·”为四元数乘法。数值积分后需对四元数重新正规化以保持其有效性。

### 二、碰撞检测：从离散到连续的数学判定

碰撞处理分为两步：检测（Detect）和响应（Response）。检测的核心是几何相交性测试。

1. **连续碰撞检测（CCD）**: 为防止高速物体在离散时间步间“穿过”障碍物（隧道效应），CCD 检测物体在整个运动路径上的连续性。

- **基于射线的检测**：将物体从起点 Pstart 到终点 Pend 的运动视为一条射线  P(t) = P₀ + t V （ t ∈ [0, 1] ， V = Pend - Pstart ）。检测该射线与障碍物的最早交点。

- **基于扫掠几何体的检测**：使用一个几何体（如球体、胶囊体）沿位移向量 D 进行扫掠，定义扫掠体  S(t) = P₀ + t D 。计算其与场景几何体的最早相交时间 t 。若发生碰撞，常用**二次扫掠法**处理响应：将剩余位移投影到碰撞法线垂直的平面上，再次进行扫掠判定以模拟滑行。

- **基于有号距离场（SDF）的方法**：预计算存放每个点到最近障碍物距离 φ(x) 的SDF场。对于半径为 r 的运动圆盘，在路径上采样 φ(x) ，若 φ(x) ≤ r 则判定碰撞。圆盘投射算法通过沿移动方向迭代推进，每步根据当前 φ 值计算安全步长（ 安全步长 = φ - r ），高效且稳定。

1. **数学判定条件**: 不同的方法对应不同的核心判定条件。

| 方法                         | 检测条件（运动体 vs 静止障碍）            | 数学表示/关键量                                |
| ---------------------------- | ----------------------------------------- | ---------------------------------------------- |
| **射线投射**                 | 射线与几何体有交点，且交点参数  t ∈ [0,1] | P(t) = P₀ + tV                                 |
| **扫掠查询**                 | 扫掠体与几何体有交，且时间参数  t ∈ [0,1] | S(t) = P₀ + tD                                 |
| **SDF圆盘投射**              | 路径上存在点  x 使得  φ(x) ≤ r            | φ(x) 为SDF值， r 为圆盘半径                    |
| **基本几何相交**（书中基础） | 如射线与平面： t = -(L·Q)/(L·V)           | L 为平面（齐次表示）， Q 为射线起点， V 为方向 |

### 三、弹簧-质点系统：柔性体的离散化建模

对于布料、头发等无法用刚体描述的柔性体，常采用**弹簧-质点系统**进行建模。其核心思想是将连续体离散化为由质点和连接弹簧构成的网络。

1. **数学模型与受力分析**: 系统由  N 个位置为  xi(t) 的质点构成，质点间通过弹簧连接。每个质点  i 的受力包括：

- **弹簧力（Fs）**：遵循胡克定律，与弹簧形变成正比，方向沿弹簧方向。 Fs = -k (xj - xi) ， k 为刚度系数。

- **阻尼力（Fd）**：用于耗散能量，防止系统无限振荡。 Fd = -c (vj - vi) ， c 为阻尼系数， v 为速度。

- **外力（如重力Fg）**： Fg = mi g 。 根据牛顿第二定律，每个质点的运动方程为： mi ẍi = ΣFs + ΣFd + Fg 。对于整个系统，可写为矩阵形式： M ẍ = F(x, v) ，其中  M 为质量矩阵。

1. **在布料与头发模拟中的应用**:

- **布料模拟**：主要通过弹簧网络模拟布料的**拉伸、剪切和弯曲**抵抗。为真实感，常需组合不同类别的弹簧（如结构弹簧、剪切弹簧、弯曲弹簧）。

- **头发模拟**：常采用更精确的**离散弹性杆（DER）模型**，它将发丝建模为分段线性杆。除了拉伸弹簧力，还显式地通过相邻段间的**角度变化**计算**弯曲力**（ Fb = -kb Δθ ），以及通过绕轴**扭转角位移**计算**扭转力**（ Ft = -kt Δφ ）。

1. **数值求解**: 上述运动方程是二阶微分方程，需通过数值积分在时间上步进求解。

- **显式欧拉法**：简单直接， x(t+Δt) = x(t) + v(t)Δt ， v(t+Δt) = v(t) + a(t)Δt ，但稳定性差，易发散。

- **隐式方法（如Verlet积分）**：更稳定，常用于此类系统。位置更新公式为： x(t+Δt) = 2x(t) - x(t-Δt) + a(t)Δt² 。

### 四、实现考量：数值稳定与性能优化

将上述数学模型转化为稳定、高效的游戏代码，还需应对数值与计算层面的挑战。

1. **数值稳定性问题**：

- **浮点误差**：连续的浮点运算会积累舍入误差，可能导致物理模拟能量异常或抖动。除使用更高精度（双精度）外，在关键比较（如碰撞检测）中引入**容差值（epsilon）**是常见做法。

- **积分方法选择**：简单的显式欧拉法在刚度大或步长长时极易失稳。采用**半隐式欧拉法**或**Verlet积分**能显著提升稳定性。资料中也提及使用**Heun方法（预估-校正法）**来减少误差。

- **确定性同步**：对于网络游戏，保证不同客户端模拟结果一致至关重要。采用**定点数**代替浮点数进行物理运算是保证确定性的有效方案，它通过整数和预设的比例因子来表示小数。

1. **性能优化技术**：

- **空间分割与加速结构**：暴力检测所有物体两两碰撞开销巨大。使用**层次包围盒（BVH）**、**四叉树/八叉树**或**均匀网格**等空间数据结构，可以快速剔除明显不相关物体的检测。

- **细节层级（LOD）**：根据物体重要性或距离，简化其物理表示。例如，远处的物体可使用球形碰撞体代替复杂网格，复杂形状用层次包围体加速求交。

- **并行计算**：物理模拟中许多任务（如多刚体状态更新、独立弹簧力计算、空间划分的更新）可以并行化，利用现代CPU的多核或GPU进行加速。

- **预计算与缓存**：对于不变或变化缓慢的数据进行预计算，如离线计算复杂模型的惯性张量、预烘焙动画的碰撞体序列等，能减少实时计算量。

综上所述，物理仿真是将牛顿力学、几何学和数值分析深度结合的领域。从刚体的宏观运动，到微观的质点振动，再到物体间精确的碰撞交互，每一步都构筑在坚实的数学基础与精巧的数值算法之上，共同创造了游戏世界中可信的动态法则。
